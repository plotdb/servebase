// Generated by LiveScript 1.6.0
(function(){
  var pg, lderror, sessionStore, userStore, aux, database;
  pg = require('pg');
  lderror = require('lderror');
  sessionStore = require('./session-store');
  userStore = require('./user-store');
  aux = require('@servebase/backend/aux');
  pg.defaults.poolSize = 30;
  database = function(backend, opt){
    var config, log, ref$, ref1$, user, password, host, database, port, poolSize;
    opt == null && (opt = {});
    this._ = {};
    this.config = config = backend.config;
    this.log = log = backend.log.child({
      module: 'db'
    });
    this._.settings = !config.db.postgresql.profile
      ? config.db.postgresql
      : import$(import$({}, config.db.postgresql), ((ref$ = config.db.postgresql) != null ? ref$.profiles[config.db.postgresql.profile] : void 8) || {});
    ref1$ = this._.settings, user = ref1$.user, password = ref1$.password, host = ref1$.host, database = ref1$.database, port = ref1$.port, poolSize = ref1$.poolSize;
    this.uri = "postgres://" + user + ":" + password + "@" + host + (port ? ':' + port : '') + "/" + database;
    this.pool = new pg.Pool({
      connectionString: this.uri,
      max: poolSize || 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000
    });
    this.pool.on('error', function(err, client){
      return log.error("db pool error".red);
    });
    this.sessionStore = new sessionStore({
      db: this,
      session: backend.config.session.maxAge,
      logger: log,
      queryOnly: opt.queryOnly
    });
    this.userStore = new userStore({
      db: this,
      config: config,
      logger: log
    });
    return this;
  };
  database.prototype = import$(Object.create(Object.prototype), {
    settings: function(){
      return this._.settings;
    },
    audit: function(c){
      return this.queryAudit(q);
    },
    queryAudit: function(q, p, c){
      var ref$, audit, hasQuery, doAudit, isAtomic;
      if (typeof q === 'object' && q.audit) {
        ref$ = [q, undefined, undefined], c = ref$[0], q = ref$[1], p = ref$[2];
      }
      audit = c != null ? c.audit : void 8;
      ref$ = [!!q, !!audit, (audit != null ? audit.atomic : void 8) || !((audit != null ? audit.atomic : void 8) != null)], hasQuery = ref$[0], doAudit = ref$[1], isAtomic = ref$[2];
      if (!(hasQuery || doAudit)) {
        return lderror.reject(1015);
      }
      return this.pool.connect().then(function(client){
        var req;
        if (!doAudit) {
          return client.query(q, p)['finally'](function(){
            return client.release();
          });
        }
        req = audit.req;
        return Promise.resolve().then(function(){
          if (isAtomic) {
            return client.query('BEGIN');
          }
        }).then(function(){
          return (hasQuery
            ? client.query(q, p)
            : Promise.resolve({})).then(function(queryResult){
            var detail, ref$;
            detail = import$((ref$ = {
              action: audit.action,
              user: audit.user
            }, ref$.data = import$(import$({
              'new': audit['new'] || p
            }, audit.old != null
              ? {
                old: audit.old
              }
              : {}), req != null && req.query
              ? {
                query: req.query
              }
              : {}), ref$), req
              ? {
                path: req.path,
                ip: aux.ip(req)
              }
              : {});
            client.query("insert into auditlog (action,option,session,ip,owner,detail) values ($1,$2,$3,$4,$5,$6)", [audit.action, audit.option, req != null ? req.sessionID : void 8, detail.ip, audit.user, detail]);
            return !isAtomic
              ? queryResult
              : client.query('COMMIT').then(function(){
                return queryResult;
              });
          });
        })['catch'](function(e){
          return !isAtomic
            ? Promise.reject(e)
            : client.query('ROLLBACK')['finally'](function(){
              return Promise.reject(e);
            });
        })['finally'](function(){
          return client.release();
        });
      })['catch'](function(e){
        return Promise.reject(new lderror({
          err: e,
          id: 0,
          query: q,
          message: "database query error"
        }));
      });
    },
    query: function(q, p){
      return this.pool.connect().then(function(client){
        return client.query(q, p).then(function(ret){
          client.release();
          return ret;
        });
      })['catch'](function(it){
        return Promise.reject(new lderror({
          err: it,
          id: 0,
          query: q,
          message: "database query error"
        }));
      });
    }
  });
  module.exports = database;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
